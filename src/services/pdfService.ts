import PDFDocument from 'pdfkit';
import type { AuditMemory } from './memory.js';

// ─── Design Tokens ────────────────────────────────────────────────────────────
const NAVY   = '#0D1B2A';
const BLUE   = '#1B4F8A';
const ACCENT = '#2563EB';
const GRAY   = '#6B7280';
const WHITE  = '#FFFFFF';
const RED    = '#DC2626';
const GREEN  = '#16A34A';
const ORANGE = '#EA580C';
const FOOTER = 'Generated by VelocityCSO.com — Powered by Gemini';

const CATEGORIES: Record<string, string[]> = {
    'Market':     ['TAM Viability', 'Target Precision', 'Trend Adoption'],
    'Strategy':   ['Competitive Defensibility', 'Model Innovation', 'Flywheel Potential'],
    'Commercial': ['Pricing Power', 'CAC/LTV Ratio', 'Market Entry Speed'],
    'Operations': ['Execution Speed', 'Scalability', 'ESG Posture'],
    'Finance':    ['ROI Projection', 'Risk Tolerance', 'Capital Efficiency'],
};

const SCENARIO_LABELS: Record<string, string> = {
    RECESSION: 'Economic Recession',
    PRICE_WAR: 'Competitor Price War',
    SCALE_UP:  'Aggressive Scale-Up',
    TALENT:    'Global Talent Shortage',
};

// Inline stress prompts — avoids importing scenarios.ts circular dep
const SCENARIO_PROMPTS: Record<string, string> = {
    RECESSION: 'Global GDP contracts 3%. Consumer spending drops 15%. Credit tightens. Enterprise budgets cut 20-30%.',
    PRICE_WAR: 'A well-funded competitor cuts prices 40%. Customers demand price matching. Margins compress 25%.',
    SCALE_UP:  'Board demands 3x growth in 18 months. Headcount must triple. Infrastructure costs spike 200%.',
    TALENT:    'Senior engineering talent costs double. Key hires take 6+ months. Attrition hits 30% annually.',
};

// ─── Helpers ──────────────────────────────────────────────────────────────────
function drawHeader(doc: PDFKit.PDFDocument, title: string) {
    doc.rect(0, 0, doc.page.width, 48).fill(NAVY);
    doc.fontSize(7).fillColor(WHITE).font('Helvetica')
        .text('CONFIDENTIAL STRATEGY AUDIT', 40, 18, { align: 'left' });
    doc.fontSize(7).fillColor(WHITE)
        .text(title, 0, 18, { align: 'right', width: doc.page.width - 40 });
}

function drawFooter(doc: PDFKit.PDFDocument, page: number) {
    const y = doc.page.height - 32;
    doc.rect(0, y, doc.page.width, 32).fill(NAVY);
    doc.fontSize(7).fillColor(WHITE).font('Helvetica')
        .text(FOOTER, 40, y + 10, { align: 'left' });
    doc.text(`Page ${page}`, 0, y + 10, { align: 'right', width: doc.page.width - 40 });
}

function sectionTitle(doc: PDFKit.PDFDocument, text: string, y: number) {
    doc.rect(40, y, 4, 16).fill(ACCENT);
    doc.fontSize(10).fillColor(NAVY).font('Helvetica-Bold').text(text, 52, y + 1);
    return y + 26;
}

function scoreBar(doc: PDFKit.PDFDocument, label: string, score: number, baseline: number | undefined, y: number, colX = 40, colW = 480) {
    const barX = colX + 150;
    const barW = colW - 170;
    const filled = Math.round((score / 100) * barW);
    const color = score >= 70 ? GREEN : score >= 40 ? BLUE : RED;
    const dropped = baseline !== undefined && (baseline - score) > 10;
    doc.fontSize(7.5).fillColor(dropped ? ORANGE : NAVY).font(dropped ? 'Helvetica-Bold' : 'Helvetica')
        .text((dropped ? '▼ ' : '') + label, colX, y, { width: 148 });
    doc.rect(barX, y + 2, barW, 7).fill('#E5E7EB');
    doc.rect(barX, y + 2, filled, 7).fill(color);
    if (baseline !== undefined && dropped) {
        const baselineFilled = Math.round((baseline / 100) * barW);
        doc.rect(barX + filled, y + 2, baselineFilled - filled, 7).fillOpacity(0.3).fill(GRAY).fillOpacity(1);
    }
    doc.fontSize(7.5).fillColor(color).font('Helvetica-Bold').text(`${score}`, barX + barW + 4, y);
    if (baseline !== undefined && dropped) {
        doc.fontSize(6.5).fillColor(RED).font('Helvetica').text(`↓${baseline - score}`, barX + barW + 22, y + 1);
    }
    return y + 15;
}

function addPage(doc: PDFKit.PDFDocument, orgName: string) {
    doc.addPage();
    drawHeader(doc, orgName);
    return 60;
}

function extractOrgName(context: string): string {
    const match = context.match(/^([A-Z][a-zA-Z\s&]{2,40})/);
    return match ? match[1].trim() : 'Your Organisation';
}

function extractKillerMove(report: string): string {
    const match = report.match(/\*\*([^*]{10,120})\*\*/);
    if (match) return match[1].trim().slice(0, 120);
    const lines = report.split('\n').filter(l => l.trim().length > 20);
    return lines[0]?.replace(/[#*]/g, '').trim().slice(0, 120) || 'Strategic audit complete.';
}

// Run a single stress scenario via Gemini directly (no ADK runner needed)
async function runStressScenario(
    scenarioId: string,
    businessContext: string,
    dimensionScores: Record<string, number>
): Promise<{ stressedScores: Record<string, number>; mitigationCards: any[] }> {
    try {
        const { LlmAgent, InMemoryRunner, isFinalResponse } = await import('@google/adk');
        const { randomUUID } = await import('crypto');

        const dimNames = Object.keys(CATEGORIES).flatMap(k => CATEGORIES[k]);
        const prompt = `
You are a stress-test analyst. Given this business context and baseline scores, recalculate all 15 dimensions under the crisis scenario.

BUSINESS: ${businessContext.slice(0, 500)}

BASELINE SCORES: ${JSON.stringify(dimensionScores)}

CRISIS: ${SCENARIO_PROMPTS[scenarioId]}

Return ONLY raw JSON:
{
  "stressed_scores": { "TAM Viability": 60, ... all 15 ... },
  "mitigation_cards": [
    { "dimension": "...", "stressed_score": 30, "risk_delta": 20, "mitigation_steps": ["...","...","..."], "cso_crisis_play": "..." }
  ]
}
Only include dimensions with stressed_score < 40 in mitigation_cards.
Dimensions: ${dimNames.join(', ')}`.trim();

        const agent = new LlmAgent({
            name: 'pdf_stress_agent',
            model: 'gemini-2.5-flash',
            description: 'Stress test for PDF',
            instruction: 'Return only raw JSON as instructed.',
        });
        const runner = new InMemoryRunner({ agent, appName: 'pdf_stress' });
        const sid = randomUUID();
        await runner.sessionService.createSession({ appName: 'pdf_stress', userId: 'pdf_user', sessionId: sid });
        const stream = runner.runAsync({ userId: 'pdf_user', sessionId: sid, newMessage: { role: 'user', parts: [{ text: prompt }] } });
        let raw = '';
        for await (const ev of stream) {
            if (ev.author === agent.name || isFinalResponse(ev)) {
                const text = (ev.content?.parts || []).map((p: any) => p.text).filter(Boolean).join('');
                if (text) raw += text;
            }
        }
        const m = raw.match(/\{[\s\S]*\}/);
        if (m) {
            const p = JSON.parse(m[0]);
            return { stressedScores: p.stressed_scores || {}, mitigationCards: p.mitigation_cards || [] };
        }
    } catch { /* fallback below */ }

    // Fallback: apply fixed deltas
    const stressedScores: Record<string, number> = {};
    const deltas: Record<string, number> = { RECESSION: -18, PRICE_WAR: -15, SCALE_UP: -12, TALENT: -10 };
    const delta = deltas[scenarioId] || -12;
    for (const [dim, score] of Object.entries(dimensionScores)) {
        stressedScores[dim] = Math.max(0, score + delta);
    }
    return { stressedScores, mitigationCards: [] };
}

// ─── Main export ──────────────────────────────────────────────────────────────
export async function generatePDF(memory: AuditMemory): Promise<Buffer> {
    // Run all 4 stress scenarios in parallel before building PDF
    const scenarioIds = ['RECESSION', 'PRICE_WAR', 'SCALE_UP', 'TALENT'];
    const stressResults = await Promise.all(
        scenarioIds.map(id => runStressScenario(id, memory.businessContext, memory.dimensionScores))
    );
    const stressMap: Record<string, { stressedScores: Record<string, number>; mitigationCards: any[] }> = {};
    scenarioIds.forEach((id, i) => { stressMap[id] = stressResults[i]; });

    return new Promise((resolve, reject) => {
        const chunks: Buffer[] = [];
        const doc = new PDFDocument({ size: 'A4', margin: 0, bufferPages: true });
        doc.on('data', (chunk: Buffer) => chunks.push(chunk));
        doc.on('end', () => resolve(Buffer.concat(chunks)));
        doc.on('error', reject);
        _buildPDF(doc, memory, stressMap);
    });
}

function _buildPDF(
    doc: PDFKit.PDFDocument,
    memory: AuditMemory,
    stressMap: Record<string, { stressedScores: Record<string, number>; mitigationCards: any[] }>
): void {
    const orgName = extractOrgName(memory.businessContext || '');
    const killerMove = extractKillerMove(memory.report);
    const dims = memory.dimensionScores;
    const overallScore = Object.values(dims).length
        ? Math.round(Object.values(dims).reduce((a, b) => a + b, 0) / Object.values(dims).length)
        : 0;
    const date = new Date().toLocaleDateString('en-GB', { day: 'numeric', month: 'long', year: 'numeric' });
    let page = 1;

    // ── PAGE 1: Cover ─────────────────────────────────────────────────────────
    drawHeader(doc, orgName);
    doc.rect(0, 48, doc.page.width, 200).fill(NAVY);
    doc.fontSize(24).fillColor(WHITE).font('Helvetica-Bold').text('Executive Strategy Audit', 40, 72);
    doc.fontSize(15).fillColor('#93C5FD').font('Helvetica').text(orgName, 40, 106);
    doc.fontSize(9).fillColor(GRAY).text(`${date}  ·  Overall Score: ${overallScore}/100`, 40, 132);

    let y = 270;
    y = sectionTitle(doc, 'Executive Verdict', y);
    doc.fontSize(13).fillColor(NAVY).font('Helvetica-Bold')
        .text(`"${killerMove}"`, 40, y, { width: doc.page.width - 80 });
    y = doc.y + 20;

    const moatLabel = overallScore >= 70 ? 'STRONG MOAT' : overallScore >= 40 ? 'DEVELOPING MOAT' : 'FRAGILE MOAT';
    const moatColor = overallScore >= 70 ? GREEN : overallScore >= 40 ? BLUE : RED;
    doc.rect(40, y, 130, 26).fill(moatColor);
    doc.fontSize(10).fillColor(WHITE).font('Helvetica-Bold').text(moatLabel, 40, y + 7, { width: 130, align: 'center' });
    doc.fontSize(9).fillColor(NAVY).font('Helvetica').text(`Confidence: ${overallScore}/100`, 184, y + 8);
    drawFooter(doc, page++);

    // ── PAGE 2: 15-Dimension Heatmap ──────────────────────────────────────────
    y = addPage(doc, orgName);
    y = sectionTitle(doc, '15-Dimension Strategic Heatmap', y);

    for (const [cat, dimList] of Object.entries(CATEGORIES)) {
        doc.fontSize(8).fillColor(ACCENT).font('Helvetica-Bold').text(cat.toUpperCase(), 40, y);
        y += 13;
        for (const dim of dimList) {
            y = scoreBar(doc, dim, dims[dim] ?? 0, undefined, y);
        }
        y += 6;
    }
    y += 6;
    doc.fontSize(7).fillColor(GRAY).font('Helvetica')
        .text('Green = Strong (70+)   Blue = Developing (40-69)   Red = At Risk (<40)', 40, y);
    drawFooter(doc, page++);

    // ── PAGES 3+: Full Strategy Report ────────────────────────────────────────
    y = addPage(doc, orgName);
    y = sectionTitle(doc, 'Full Strategy Report', y);

    const cleanReport = memory.report
        .replace(/```[a-z]*/gi, '').replace(/```/g, '')
        .replace(/\r\n/g, '\n');

    const lines = cleanReport.split('\n');
    const pageBottom = doc.page.height - 44;

    for (const line of lines) {
        if (y > pageBottom) {
            drawFooter(doc, page++);
            y = addPage(doc, orgName);
        }
        const trimmed = line.trim();
        if (!trimmed) { y += 5; continue; }

        if (/^#{1,2}\s/.test(trimmed)) {
            if (y > pageBottom - 30) { drawFooter(doc, page++); y = addPage(doc, orgName); }
            const text = trimmed.replace(/^#+\s*/, '');
            y += 6;
            doc.rect(40, y, 4, 14).fill(ACCENT);
            doc.fontSize(10).fillColor(NAVY).font('Helvetica-Bold').text(text, 52, y + 1, { width: doc.page.width - 92 });
            y = doc.y + 6;
        } else if (/^#{3,}\s/.test(trimmed)) {
            const text = trimmed.replace(/^#+\s*/, '');
            doc.fontSize(9).fillColor(BLUE).font('Helvetica-Bold').text(text, 40, y, { width: doc.page.width - 80 });
            y = doc.y + 4;
        } else if (/^[-*]\s/.test(trimmed)) {
            const text = trimmed.replace(/^[-*]\s*/, '').replace(/\*\*/g, '');
            doc.fontSize(8).fillColor(NAVY).font('Helvetica').text(`• ${text}`, 52, y, { width: doc.page.width - 92 });
            y = doc.y + 3;
        } else {
            const text = trimmed.replace(/\*\*/g, '').replace(/\*/g, '');
            doc.fontSize(8).fillColor('#1F2937').font('Helvetica').text(text, 40, y, { width: doc.page.width - 80 });
            y = doc.y + 3;
        }
    }
    drawFooter(doc, page++);

    // ── STRESS TEST PAGES: one page per scenario ───────────────────────────────
    for (const scenarioId of ['RECESSION', 'PRICE_WAR', 'SCALE_UP', 'TALENT']) {
        const result = stressMap[scenarioId];
        if (!result) continue;

        y = addPage(doc, orgName);
        y = sectionTitle(doc, `Stress Test: ${SCENARIO_LABELS[scenarioId]}`, y);

        doc.fontSize(8).fillColor(GRAY).font('Helvetica')
            .text(SCENARIO_PROMPTS[scenarioId], 40, y, { width: doc.page.width - 80 });
        y = doc.y + 12;

        // Two-column score comparison
        const midX = doc.page.width / 2 + 10;
        doc.fontSize(8).fillColor(ACCENT).font('Helvetica-Bold').text('BASELINE', 40, y);
        doc.fontSize(8).fillColor(RED).font('Helvetica-Bold').text('STRESSED', midX, y);
        y += 14;

        const stressedAvg = Object.values(result.stressedScores).length
            ? Math.round(Object.values(result.stressedScores).reduce((a, b) => a + b, 0) / Object.values(result.stressedScores).length)
            : overallScore;

        let leftY = y, rightY = y;
        const allDims = Object.keys(CATEGORIES).flatMap(k => CATEGORIES[k]);
        const half = Math.ceil(allDims.length / 2);

        for (let i = 0; i < half; i++) {
            const dim = allDims[i];
            leftY = scoreBar(doc, dim, dims[dim] ?? 0, result.stressedScores[dim], leftY, 40, midX - 60);
        }
        for (let i = half; i < allDims.length; i++) {
            const dim = allDims[i];
            rightY = scoreBar(doc, dim, result.stressedScores[dim] ?? 0, dims[dim], rightY, midX, doc.page.width - midX - 40);
        }
        y = Math.max(leftY, rightY) + 10;

        // Score delta summary
        doc.rect(40, y, doc.page.width - 80, 22).fill('#FEF2F2');
        doc.fontSize(9).fillColor(RED).font('Helvetica-Bold')
            .text(`Overall Score: ${overallScore} → ${stressedAvg}  (Δ ${stressedAvg - overallScore})`, 44, y + 6);
        y += 30;

        // Mitigation cards
        if (result.mitigationCards.length > 0) {
            y = sectionTitle(doc, 'Failing Dimensions — Mitigation Playbook', y);
            for (const card of result.mitigationCards) {
                if (y > doc.page.height - 100) { drawFooter(doc, page++); y = addPage(doc, orgName); }
                doc.rect(40, y, doc.page.width - 80, 16).fill('#FFF7ED');
                doc.fontSize(9).fillColor(RED).font('Helvetica-Bold')
                    .text(`${card.dimension}  —  Score: ${card.stressed_score ?? card.stressedScore}  (↓${card.risk_delta ?? card.riskDelta} pts)`, 44, y + 3);
                y += 18;
                for (const step of (card.mitigation_steps || card.mitigationSteps || [])) {
                    if (y > doc.page.height - 44) { drawFooter(doc, page++); y = addPage(doc, orgName); }
                    doc.fontSize(7.5).fillColor(NAVY).font('Helvetica').text(`• ${step}`, 52, y, { width: doc.page.width - 92 });
                    y = doc.y + 2;
                }
                if (card.cso_crisis_play || card.csoCrisisPlay) {
                    if (y > doc.page.height - 44) { drawFooter(doc, page++); y = addPage(doc, orgName); }
                    doc.rect(52, y, 3, 12).fill(ACCENT);
                    doc.fontSize(7.5).fillColor(BLUE).font('Helvetica-Bold')
                        .text('CSO Play: ', 60, y, { continued: true })
                        .font('Helvetica').fillColor(NAVY)
                        .text((card.cso_crisis_play || card.csoCrisisPlay).slice(0, 200), { width: doc.page.width - 100 });
                    y = doc.y + 8;
                }
                y += 6;
            }
        }
        drawFooter(doc, page++);
    }

    doc.end();
}
